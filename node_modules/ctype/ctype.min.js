var mod_ctf=require("./ctf.js"),mod_ctio=require("./ctio.js"),mod_assert=require("assert"),deftypes={uint8_t:{read:ctReadUint8,write:ctWriteUint8},uint16_t:{read:ctReadUint16,write:ctWriteUint16},uint32_t:{read:ctReadUint32,write:ctWriteUint32},uint64_t:{read:ctReadUint64,write:ctWriteUint64},int8_t:{read:ctReadSint8,write:ctWriteSint8},int16_t:{read:ctReadSint16,write:ctWriteSint16},int32_t:{read:ctReadSint32,write:ctWriteSint32},int64_t:{read:ctReadSint64,write:ctWriteSint64},"float":{read:ctReadFloat,
write:ctWriteFloat},"double":{read:ctReadDouble,write:ctWriteDouble},"char":{read:ctReadChar,write:ctWriteChar},"char[]":{read:ctReadCharArray,write:ctWriteCharArray}};function ctReadUint8(a,b,c){return{value:mod_ctio.ruint8(b,a,c),size:1}}function ctReadUint16(a,b,c){return{value:mod_ctio.ruint16(b,a,c),size:2}}function ctReadUint32(a,b,c){return{value:mod_ctio.ruint32(b,a,c),size:4}}function ctReadUint64(a,b,c){return{value:mod_ctio.ruint64(b,a,c),size:8}}
function ctReadSint8(a,b,c){return{value:mod_ctio.rsint8(b,a,c),size:1}}function ctReadSint16(a,b,c){return{value:mod_ctio.rsint16(b,a,c),size:2}}function ctReadSint32(a,b,c){return{value:mod_ctio.rsint32(b,a,c),size:4}}function ctReadSint64(a,b,c){return{value:mod_ctio.rsint64(b,a,c),size:8}}function ctReadFloat(a,b,c){return{value:mod_ctio.rfloat(b,a,c),size:4}}function ctReadDouble(a,b,c){return{value:mod_ctio.rdouble(b,a,c),size:8}}
function ctReadChar(a,b,c){var d=new Buffer(1);d[0]=mod_ctio.ruint8(b,a,c);return{value:d,size:1}}function ctReadCharArray(a,b,c,d){var e,f=new Buffer(a);for(e=0;e<a;e++)f[e]=mod_ctio.ruint8(c,b,d+e);return{value:f,size:a}}function ctWriteUint8(a,b,c,d){mod_ctio.wuint8(a,b,c,d);return 1}function ctWriteUint16(a,b,c,d){mod_ctio.wuint16(a,b,c,d);return 2}function ctWriteUint32(a,b,c,d){mod_ctio.wuint32(a,b,c,d);return 4}function ctWriteUint64(a,b,c,d){mod_ctio.wuint64(a,b,c,d);return 8}
function ctWriteSint8(a,b,c,d){mod_ctio.wsint8(a,b,c,d);return 1}function ctWriteSint16(a,b,c,d){mod_ctio.wsint16(a,b,c,d);return 2}function ctWriteSint32(a,b,c,d){mod_ctio.wsint32(a,b,c,d);return 4}function ctWriteSint64(a,b,c,d){mod_ctio.wsint64(a,b,c,d);return 8}function ctWriteFloat(a,b,c,d){mod_ctio.wfloat(a,b,c,d);return 4}function ctWriteDouble(a,b,c,d){mod_ctio.wdouble(a,b,c,d);return 8}
function ctWriteChar(a,b,c,d){if(!(a instanceof Buffer))throw Error("Input must be a buffer");mod_ctio.ruint8(a[0],b,c,d);return 1}function ctWriteCharArray(a,b,c,d,e){var f;if(!(a instanceof Buffer))throw Error("Input must be a buffer");if(a.length>b)throw Error("value length greater than array length");for(f=0;f<a.length&&f<b;f++)mod_ctio.wuint8(a[f],c,d,e+f);for(;f<b;f++)mod_ctio.wuint8(0,c,e+f);return b}function ctGetBasicTypes(){var a={},b;for(b in deftypes)a[b]=deftypes[b];return a}
function ctParseType(a){var b,c,d;if("string"!=typeof a)throw Error("type must be a Javascript string");c=a.lastIndexOf("]");if(-1==c){if(-1!=a.lastIndexOf("["))throw Error("found invalid type with '[' but no corresponding ']'");return{type:a}}b=a.lastIndexOf("[");if(-1==b)throw Error("found invalid type with ']' but no corresponding '['");if(b>=c)throw Error("malformed type, ']' appears before '['");d=a.substring(0,b);a=a.substring(b+1,c);return{type:d,len:a}}
function ctCheckReq(a,b,c){var d,e,f,g,h={};if(!(a instanceof Array))throw Error("definition is not an array");if(0===a.length)throw Error("definition must have at least one element");for(d=0;d<a.length;d++){f=a[d];if(!(f instanceof Object))throw Error("definition must be an array ofobjects");g=Object.keys(f);if(1!=g.length)throw Error("definition entry must only have one key");if(g[0]in h)throw Error("Specified name already specified: "+g[0]);if(!("type"in f[g[0]]))throw Error("missing required type definition");
for(e=ctParseType(f[g[0]].type);void 0!==e.len;){if(isNaN(parseInt(e.len,10))&&!(e.len in h))throw Error("Given an array length without a matching type");e=ctParseType(e.type)}if(!(e.type in b))throw Error("type not found or typdefed: "+e.type);if(void 0!==c)for(e=0;e<c.length;e++)if(!(c[e]in f[g[0]]))throw Error("Missing required field: "+c[e]);h[g[0]]=!0}}
function CTypeParser(a){if(!a)throw Error("missing required argument");if(!("endian"in a))throw Error("missing required endian value");if("big"!=a.endian&&"little"!=a.endian)throw Error("Invalid endian type");if("char-type"in a&&"uint8"!=a["char-type"]&&"int8"!=a["char-type"])throw Error("invalid option for char-type: "+a["char-type"]);this.endian=a.endian;this.types=ctGetBasicTypes();"char-type"in a&&"uint8"==a["char-type"]&&(this.types["char"]=this.types.uint8_t);"char-type"in a&&"int8"==a["char-type"]&&
(this.types["char"]=this.types.int8_t)}CTypeParser.prototype.setEndian=function(a){if("big"!=a&&"little"!=a)throw Error("invalid endian type, must be big or little");this.endian=a};CTypeParser.prototype.getEndian=function(){return this.endian};
CTypeParser.prototype.typedef=function(a,b){var c;if(void 0===a)throw new (Error("missing required typedef argument: name"));if(void 0===b)throw new (Error("missing required typedef argument: value"));if("string"!=typeof a)throw new (Error("the name of a type must be a string"));c=ctParseType(a);if(void 0!==c.len)throw Error("Cannot have an array in the typedef name");if(a in this.types)throw Error("typedef name already present: "+a);if("string"!=typeof b&&!(b instanceof Array))throw Error("typedef value must either be a string or struct");
if("string"==typeof b){if(c=ctParseType(b),void 0!==c.len&&isNaN(parseInt(c.len,10)))throw new (Error("typedef value must use fixed size array when outside of a struct"));}else ctCheckReq(b,this.types);this.types[a]=b};CTypeParser.prototype.lstypes=function(){var a,b={};for(a in this.types)a in deftypes||(b[a]=this.types[a]);return b};
function ctResolveArray(a,b){for(var c="",d=ctParseType(a);void 0!==d.len;){if(isNaN(parseInt(d.len,10))){if("number"!=typeof b[d.len])throw Error("cannot sawp in non-number for array value");c="["+b[d.len]+"]"+c}else c="["+d.len+"]"+c;d=ctParseType(d.type)}return c=d.type+c}
CTypeParser.prototype.resolveTypedef=function(a,b,c,d,e){mod_assert.ok(a in this.types);if("string"==typeof this.types[a]){a=ctParseType(this.types[a]);if("read"==b)return this.readEntry(a,c,d);if("write"==b)return this.writeEntry(e,a,c,d);throw Error("invalid dispatch type to resolveTypedef");}if("read"==b)return this.readStruct(this.types[a],c,d);if("write"==b)return this.writeStruct(e,this.types[a],c,d);throw Error("invalid dispatch type to resolveTypedef");};
CTypeParser.prototype.readEntry=function(a,b,c){var d;if(void 0!==a.len){d=parseInt(a.len,10);if(isNaN(d))throw Error("somehow got a non-numeric length");a="char"==a.type?this.types["char[]"].read(d,this.endian,b,c):this.readArray(a.type,d,b,c)}else a=a.type in deftypes?this.types[a.type].read(this.endian,b,c):this.resolveTypedef(a.type,"read",b,c);return a};
CTypeParser.prototype.readArray=function(a,b,c,d){var e,f,g=d,h=Array(b);f=ctParseType(a);for(a=0;a<b;a++)e=this.readEntry(f,c,d),d+=e.size,h[a]=e.value;return{value:h,size:d-g}};CTypeParser.prototype.readStruct=function(a,b,c){var d,e,f,g,h=c,k={};for(e=0;e<a.length;e++)g=Object.keys(a[e])[0],f=a[e][g],d=ctParseType(ctResolveArray(f.type,k)),"offset"in f&&(c=h+f.offset),d=this.readEntry(d,b,c),c+=d.size,k[g]=d.value;return{value:k,size:c-h}};
CTypeParser.prototype.readData=function(a,b,c){if(void 0===a)throw Error("missing definition for what we should beparsing");if(void 0===b)throw Error("missing buffer for what we should be parsing");if(void 0===c)throw Error("missing offset for what we should be parsing");ctCheckReq(a,this.types);return this.readStruct(a,b,c).value};
CTypeParser.prototype.writeArray=function(a,b,c,d,e){var f,g=e;if(!(a instanceof Array))throw Error("asked to write an array, but value is not an array");if(a.length!=c)throw Error("asked to write array of length "+c+" but that does not match value length: "+a.length);f=ctParseType(b);for(b=0;b<c;b++)e+=this.writeEntry(a[b],f,d,e);return e-g};
CTypeParser.prototype.writeEntry=function(a,b,c,d){var e;if(void 0!==b.len){e=parseInt(b.len,10);if(isNaN(e))throw Error("somehow got a non-numeric length");a="char"==b.type?this.types["char[]"].write(a,e,this.endian,c,d):this.writeArray(a,b.type,e,c,d)}else a=b.type in deftypes?this.types[b.type].write(a,this.endian,c,d):this.resolveTypedef(b.type,"write",c,d,a);return a};
CTypeParser.prototype.writeStruct=function(a,b,c,d){var e,f,g,h,k=d,l={};for(e=0;e<b.length;e++)h=Object.keys(b[e])[0],f=b[e][h],g=ctParseType(ctResolveArray(f.type,l)),"offset"in f&&(d=k+f.offset),d+=this.writeEntry(a[e],g,c,d),l[h]=a[e];return d};function getValues(a){var b,c,d;c=[];for(b=0;b<a.length;b++)d=Object.keys(a[b])[0],mod_assert.ok("value"in a[b][d]),c.push(a[b][d].value);return c}
CTypeParser.prototype.writeData=function(a,b,c,d){var e;if(void 0===a)throw Error("missing definition for what we should beparsing");if(void 0===b)throw Error("missing buffer for what we should be parsing");if(void 0===c)throw Error("missing offset for what we should be parsing");if(e=null!=d&&void 0!=d){if(!Array.isArray(d))throw Error("missing values for writing");ctCheckReq(a,this.types)}else ctCheckReq(a,this.types,["value"]);this.writeStruct(e?d:getValues(a),a,b,c)};
function toAbs64(a){if(void 0===a)throw Error("missing required arg: value");if(!Array.isArray(a))throw Error("value must be an array");if(2!=a.length)throw Error("value must be an array of length 2");if(1048576<=a[0])throw Error("value would become approximated");return a[0]*Math.pow(2,32)+a[1]}
function toApprox64(a){if(void 0===a)throw Error("missing required arg: value");if(!Array.isArray(a))throw Error("value must be an array");if(2!=a.length)throw Error("value must be an array of length 2");return Math.pow(2,32)*a[0]+a[1]}function parseCTF(a,b){var c=new CTypeParser(b);mod_ctf.ctfParseJson(a,c);return c}exports.Parser=CTypeParser;exports.toAbs64=toAbs64;exports.toApprox64=toApprox64;exports.parseCTF=parseCTF;exports.ruint8=mod_ctio.ruint8;exports.ruint16=mod_ctio.ruint16;
exports.ruint32=mod_ctio.ruint32;exports.ruint64=mod_ctio.ruint64;exports.wuint8=mod_ctio.wuint8;exports.wuint16=mod_ctio.wuint16;exports.wuint32=mod_ctio.wuint32;exports.wuint64=mod_ctio.wuint64;exports.rsint8=mod_ctio.rsint8;exports.rsint16=mod_ctio.rsint16;exports.rsint32=mod_ctio.rsint32;exports.rsint64=mod_ctio.rsint64;exports.wsint8=mod_ctio.wsint8;exports.wsint16=mod_ctio.wsint16;exports.wsint32=mod_ctio.wsint32;exports.wsint64=mod_ctio.wsint64;exports.rfloat=mod_ctio.rfloat;
exports.rdouble=mod_ctio.rdouble;exports.wfloat=mod_ctio.wfloat;exports.wdouble=mod_ctio.wdouble; //# sourceMappingURL=ctype.js.map
